## Decoder

A `Decoder` accepts an exact cover (in the form of a set of row
numbers), and emits a human-readable solution.

    my $decoder = $encoder.decoder; # see 02-encoder.md
    my $solution = ...; # array of row numbers
    
    $decoder.decode($solution);

The only method on a `Decoder` is `.decode`; it takes an array of integer
values.

Usually the `Decoder` will print to `STDOUT`, but the exact method could
vary; it could equally well be plotting graphics directly on a screen,
or sending a solution over a network.

There is a `Decoder` provided by `dlx-simple`, called `Decoder::Rowset`,
that writes solutions on the form `[1, 2, 3]` to `STDOUT`. A `Solver`
will use a `Decoder::Rowset` when no `Decoder` was provided. Its only
function is to emit something while a given problem does not yet have
a dedicated `Decoder`; its use beyond that is discouraged.

There is also a `Decoder` called `Decoder::Code`; its constructor accepts
a `:$code` argument containing code to be executed per `.decode` call.
It is intended for debugging purposes:

    my $matrix = $encoder.matrix; # see 02-encoder.md
    my @solutions;
    my $decoder = Decoder::Code.new(:code{ push @solutions, $^solution });
    my $solver = Solver::DancingLinks.new(:$matrix, :$decoder);
    
    # @solutions now contains the solutions generated by the Solver

Apart from `Decoder::Rowset` and `Decoder::Code`, a `Decoder` subclass
tends to be specially tailored to a given problem description; the
general idea is that a solution can be expressed in much the same format
as the problem description. Exactly how this will look varies, of course,
and sometimes problem desctiption and solution output will vary. But
the general idea is that the solution output aligns itself to the
problem input as much as practically possible.

This kind of `Decoder` usually expects three things in its constructor:

* a `%conf` variable containing key-value pairs with settings
* a `@locations` array of `Location` objects
* a `@mapping` array of `Placement` objects

While it is entirely possible to build these three data structures
manually, the simple way is generally to generate a `Decoder` out of its
corresponding `Encoder`:

    my $encoder = Encoder.from($human-input);
    my $decoder = $encoder.decoder;

A `Decoder` created in this way is expected to align as much as possible
to its corresponding `Encoder`.
